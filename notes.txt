Some notes on what needs to be done for pmfs

(DONE for now) Append to File
Copy File (do this at the block level really - and between file systems potentially - it's really a series of append file calls for each block)
Create file of a given type (which can also be used to create a mountable file)
Handling traversal of mounted filesystems
(DONE) Upper side caching of nodes, channel to sync updates, non-removal of cached items that are not synced
Caching of data nodes (treat data nodes separately)
Series files (pass inode and key/value to underlying)
Tags (filesystem based tagname -> key/value (and path or inode?), with the ability to search, order, filter etc.)
    e.g.   Color -> Red -> [ /one/two, /three/four]
    Find paths where color = 'Red'
    Updating tags on deletion (so perhaps a reverse index needs to also be stored)
    Tag data saved as nodes of course
Versioning
    Create new version instead of just overwriting. Version links could be perhaps tags pointing to inodes of the original file node
     instead of paths
    E.g.    Version -> /one/two/three [ 1 -> 12223, 2 -> 22211, 3 -> 23324 ]
Functions to page through a file or directory listing (byte point to byte point, series start to end, etc.)
MongoDB implementation
Cassandra implementation
Postgresql implementation
(INPROGRESS) Client side shell https://github.com/nsf/termbox-go
Thrift api + client side application (using that console based library?) (like a shell prompt with some screen stuff going on)
Web front end (browse structure, search using tags, browse versions, update data, append data, delete data, create mount points, archive versions)
Symbolic links (hard and soft)
Channel on shell to show output from filesystem execution (messages basically)


Sample commands through the "shell"

cd /alan   ; do a stat on the folder
ls         ; dir listing
cat /alan/1  ; print out contents
append /alan/1 content  ; add to file
append 1 content  ; add to file, using the current directory
rm 1    ; delete a file
copy 1 2  ; copy one file to another
stat 1  ; print out information on a file
mount /fred/mongo mongodb:/127.0.0.1:1222/db collectionName
append /fred/mongo/one Some content ; Would now be writing to mongodb
cat /fred/mongo ; Would write out some information about the mount point
rm /fred/mongo ; Would remove that mount point (maybe not removing the data?)

(DONE) delete command in shell
When you create a file (add a file) you need to specify the mime type (it defaults to text/plain). The mime type
is stored in the File node.
A directory node can be a mount type. If we traverse through that we pass on the remaining path to the cached filesystem
associated with that node id, if the cached fs does not exist we load it from the contents of the extended Block node attributes
of the directory node (which should contain some structure that was passed during an "add mount" call)

Some bugs

(DONE) appending data goes into continuation continually once it starts
